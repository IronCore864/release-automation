import argparse
import logging
import os
import re
import subprocess
import time
from datetime import datetime
from pathlib import Path
import webbrowser

import github

logger = logging.getLogger()
logger.setLevel(logging.INFO)


class MyHandler(logging.StreamHandler):
    def format(self, record):
        if record.levelno == logging.INFO:
            self.setFormatter(logging.Formatter("ℹ️ INFO: %(message)s"))
        elif record.levelno == logging.WARNING:
            self.setFormatter(logging.Formatter("⚠️ WARNING: %(message)s"))
        elif record.levelno == logging.ERROR:
            self.setFormatter(logging.Formatter("❌ ERROR: %(message)s"))
        return super().format(record)


logger.addHandler(MyHandler())

if "GITHUB_TOKEN" not in os.environ:
    logger.critical("Environment variable GITHUB_TOKEN not set.")
    exit(1)

auth = github.Auth.Token(os.getenv("GITHUB_TOKEN"))
gh_client = github.Github(auth=auth)


def get_latest_version(repo, branch_name):
    """Get the latest version from releases."""
    releases = repo.get_releases()

    for release in releases:
        if "maintenance" in branch_name:
            version = branch_name.split("-")[0]
            if version not in release.tag_name:
                continue

        return release.tag_name

    return None


def bump_version(version):
    """Bump patch version."""
    major, minor, patch = map(int, version.split("."))
    return f"{major}.{minor}.{patch + 1}"


def get_new_version(owner, repo, branch_name):
    """Get a new version for release.

    Default value is generated by increasing the patch version of the latest version.

    Can be overriden with a user-provided version.
    """
    latest_version = get_latest_version(repo, branch_name)

    if latest_version is None:
        logger.info('No version tags found in branch "{branch_name}".')
        suggested_version = ""
    else:
        suggested_version = bump_version(latest_version)
        logger.info(f'Latest version in branch "{branch_name}"": {latest_version}')
        logger.info(f"Suggested new version: {suggested_version}")

    while True:
        user_input = input(
            f"Input version to release (press enter to use suggested version {suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == "c":
            logger.warning("Release creation canceled.")
            return

        version_to_use = user_input if user_input else suggested_version

        if not version_to_use:
            logger.error("Error: No version specified and no suggestion available")
            continue

        if not re.match(r"^\d+\.\d+\.\d+$", version_to_use):
            logger.error("Error: Version must be in format X.Y.Z")
            continue

        release_page = f"https://github.com/{owner}/{repo.name}/releases"
        logger.warning(
            f"Check out the releases page: {release_page} before confirming!"
        )

        confirm = (
            input(
                f"Confirm creating release '{version_to_use}' on branch '{branch_name}'? [y/N]: "
            )
            .strip()
            .lower()
        )

        if confirm == "y":
            break

        logger.info("Let's try again...")

    return version_to_use


def create_draft_release(repo, tag, branch):
    try:
        release = repo.create_git_release(
            tag=tag,
            name=tag,
            draft=True,
            generate_release_notes=True,
            target_commitish=branch,
        )
        return release
    except Exception as e:
        logging.error(f"Error creating release: {e}")


def parse_release_notes(release_notes):
    """Parse auto-generated release notes into categories."""
    # Remove "New Contributors" section.
    release_notes = re.sub(
        r"(## New Contributors.*?)(\n|$)", r"\2", release_notes, flags=re.DOTALL
    )
    categories = {"feat": [], "fix": [], "docs": [], "test": [], "ci": []}
    full_changelog_line = None

    for line in release_notes.splitlines():
        line = line.strip()
        if line.startswith("* "):
            match = re.match(r"\* (\w+): (.*) by @\w+ in (.*)", line)
            if match:
                category = match.group(1)
                description = match.group(2).strip()
                description = description[0].upper() + description[1:]
                pr_link = match.group(3).strip()
                if category in categories:
                    categories[category].append((description, pr_link))
        elif line.startswith("**Full Changelog**"):
            full_changelog_line = line

    return categories, full_changelog_line


def format_notes(categories, full_changelog):
    """Format for release notes."""
    res = "## What's Changed\n\n"

    for commit_type, items in categories.items():
        if items:
            res += f"### {commit_type_to_category(commit_type)}\n"

            for description, pr_link in items:
                res += f"* {description} in {pr_link}\n"

            res += "\n"

    if full_changelog:
        res += full_changelog

    return res


def print_notes(notes):
    print("=" * 80)
    print("Formatted release notes:")
    print("=" * 80)
    print(notes)
    print("=" * 80)


def get_title_and_summary(auto_generated_title):
    print(f"The automatically generated title is: {auto_generated_title}")
    title = input(
        "Enter release title, press Enter to keep the auto-generated title:\n> "
    ).strip()
    if not title:
        title = auto_generated_title

    print(
        "\nEnter release summary (multi-line supported, type '.' on a new line to finish):"
    )

    lines = []
    while True:
        line = input()
        if line.strip() == ".":
            break
        lines.append(line)

    summary = "\n".join(lines).strip()
    summary = summary.lstrip("\n")
    summary = summary.rstrip("\n") + "\n"

    return title, summary


def update_release(release, title, notes):
    try:
        release.update_release(name=title, message=notes)
        logger.info("Release title and notes updated.")
    except Exception as e:
        print(f"Error creating release: {e}")


def format_changes(categories, tag):
    """Format for changelog."""
    today = datetime.now().strftime("%d %B %Y")
    res = f"# {tag} - {today}\n\n"

    for commit_type, items in categories.items():
        if items:
            res += f"## {commit_type_to_category(commit_type)}\n\n"

            for description, pr_link in items:
                match = re.match(r"https?://[^ ]+/pull/(\d+)", pr_link)
                if match:
                    pr_num = match.group(1)
                res += f"* {description} (#{pr_num})\n"

            res += "\n"

    return res


def update_changes_file(changes, changes_file):
    existing_content = ""
    if os.path.exists(changes_file):
        with open(changes_file, "r") as f:
            existing_content = f.read()

    new_content = changes + existing_content

    with open(changes_file, "w") as f:
        f.write(new_content)

    logger.info(f"Updated {changes_file} with new release notes.")


def commit_type_to_category(commit_type):
    mapping = {
        "feat": "Features",
        "fix": "Fixes",
        "docs": "Documentation",
        "test": "Tests",
        "ci": "CI",
    }
    return mapping.get(commit_type, commit_type.capitalize())


def parse_version(version_str):
    match = re.fullmatch(r"(\d+\.\d+\.\d+)(\.dev\d+)?", version_str)
    if not match:
        raise ValueError(f"Invalid version format: {version_str}")
    base_version = match.group(1)
    dev_suffix = match.group(2) or ""
    return base_version, dev_suffix


def update_ops_version(file_path, new_version):
    content = file_path.read_text()
    updated = re.sub(
        r"version: str = \'\d+\.\d+\.\d+(\.dev\d+)?\'",
        f"version: str = '{new_version}'",
        content,
    )
    file_path.write_text(updated)


def update_pyproject_version(file_path, new_version):
    content = file_path.read_text()
    updated = re.sub(
        r'version = "\d+\.\d+\.\d+(\.dev\d+)?"', f'version = "{new_version}"', content
    )
    file_path.write_text(updated)


def update_versions(version, post_release=False):
    # Define file paths
    ops_version = Path("ops/version.py")
    testing_pyproject = Path("testing/pyproject.toml")
    tracing_pyproject = Path("tracing/pyproject.toml")

    ops_version_str = r"version: str = \'(\d+\.\d+\.\d+(?:\.dev\d+)?)\'"
    pyproject_version_str = r'version = "(\d+\.\d+\.\d+(?:\.dev\d+)?)"'

    for file_path in [ops_version, testing_pyproject, tracing_pyproject]:
        if file_path == ops_version:
            content = file_path.read_text()
            current_version = re.search(ops_version_str, content).group(1)
        else:
            content = file_path.read_text()
            current_version = re.search(pyproject_version_str, content).group(1)

        if post_release:
            # After release, add the '.dev0' suffix.
            _, dev_suffix = parse_version(current_version)
            if dev_suffix:
                raise ValueError(f"Version already has dev suffix: {current_version}")
            new_version = version + ".dev0"
            if file_path == ops_version:
                update_ops_version(file_path, new_version)
            else:
                update_pyproject_version(file_path, new_version)
            print(f"Updated {file_path} to post-release version: {new_version}")
        else:
            if file_path == ops_version:
                update_ops_version(file_path, version)
            else:
                update_pyproject_version(file_path, version)
            print(f"Updated {file_path} to release version: {version}")


def countdown(msg, t):
    while t:
        timer = "00:{:02d}".format(t)
        print(f"{msg}: {timer}", end="\r")
        time.sleep(1)
        t -= 1


def check_update_charm_pins_prs(repo):
    prs = repo.get_pulls(state="open")
    open_prs = [pr for pr in prs if pr.title == "chore: update charm pins"]
    if open_prs:
        logger.info('Please merge "update charm pins" PRs first:')
        pr = open_prs[0]
        pr_url = f"#{pr.number} - {pr.html_url}"
        logger.info(f"  {pr_url}")
        if len(open_prs) > 1:
            logger.info(
                f"Note that there are {len(open_prs) - 1} more open update charm pins PRs."
            )
        countdown("Exiting and opening the charm pins PR in: ", 3)
        webbrowser.open(pr.html_url)
        exit(1)


def release(owner, repo_name, branch):
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    check_update_charm_pins_prs(repo)

    tag = get_new_version(owner, repo, branch)

    release = create_draft_release(repo, tag, branch)
    logger.info(f"Draft release created: {release.html_url}.")

    categories, full_changelog = parse_release_notes(release.body)
    notes = format_notes(categories, full_changelog)
    print_notes(notes)
    title, summary = get_title_and_summary(release.title)
    if not title:
        title = tag
    notes = f"{summary}\n{notes}"
    update_release(release, title, notes)

    changes = format_changes(categories, tag)
    update_changes_file(changes, "CHANGES.md")

    update_versions(tag)

    new_branch = f"release-prep-{tag}"
    subprocess.run(["git", "checkout", "-b", new_branch], check=True)
    changed_files = (
        "CHANGES.md",
        "ops/version.py",
        "testing/pyproject.toml",
        "tracing/pyproject.toml",
    )
    for f in changed_files:
        subprocess.run(["git", "add", f], check=True)
    subprocess.run(["git", "commit", "-m", f"chore: prepare release {tag}"], check=True)
    subprocess.run(["git", "push", "origin", new_branch], check=True)
    pr = repo.create_pull(
        title=f"Release Preparation: {tag}",
        body=f"This PR prepares the release of version {tag}.",
        head=f"{gh_client.get_user().login}:{new_branch}",  # "your_username:new_branch"
        base=branch,
    )
    logger.info(f"Created PR: {pr.html_url}")


def post_release():
    pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    # TODO: change the default
    parser.add_argument(
        "--repo",
        "-r",
        help='Repository name (e.g. "operator")',
        default="release-automation",
    )
    # TODO: change the default
    parser.add_argument(
        "--owner",
        "-o",
        help='Owner name (e.g. "Canonical")',
        default="IronCoreWorks",
    )
    parser.add_argument(
        "--branch", "-b", help="Branch to create the release from", default="main"
    )
    parser.add_argument(
        "--post-release",
        action="store_true",
        help="After release, bump version and add .dev0 suffix",
    )
    args = parser.parse_args()

    if not args.post_release:
        release(owner=args.owner, repo_name=args.repo, branch=args.branch)
    else:
        post_release()
